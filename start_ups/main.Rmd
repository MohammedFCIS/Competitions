---
title: "Startups Business Analytics"
author: "Mohammed Ali, Ali Ezzat"
date: "February 17, 2018"
output:
    html_document:
      toc : true
      levels : 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(quanteda)
```

# Objective
Our main goal here is to see how we can walk through a business case to analyze it and conclude useful results from it. Although the dataset here is a dummy one, it has the same issues as most real datasets like:

* A lot of predictors to comperhend and get usefl info from them.
* Data has a lot of missing, unclear items.
* Amiguate relation between the predictors

So let us begin our journey.

# Data Wrangling
First we will read the data using `read_csv` methof from `readr` packing within `tidyverse` package.

```{r read_data, message=FALSE}
startups <- read_csv("data/CAX_Startup_Data.csv")
```
So we have `r nrow(startups)` observations belongs to `r ncol(startups)` variables, one of them is the response variable that we would to designate later for predction and the rest are the predictors.

Let us see how the first 5 rows of the data looks like
```{r data_head}
head(startups, 5)
```

From that it seems we have the following notes:

* There are many missong values 
* Missing values are not only marked as `NA` but there are other values like `No Info` or just an empty string.
* Varaible are read as _characters_ datatype by default and would need to be probably converted to their _original_ data type(dates, factors, numeric)
* There are variables clearly will need special processing like `Short Description of company profile` , `Specialization of highest education` or `
Investors`
* There are issues in texual columns (upper and lower case, different format, etc..)
* Clearly `Dependent-Company Status` is the response variable.

So, the following are the steps we will conduct to clean our dataset

* Unify the way missing data are marked.
* Will convert the variables into their proper datatypes.
* Remove column with missed data over 40%.

## Setup Missing Data

```{r set_missing}
set_missing <- function(x) {
  # Replace 'No Info' with NA
  x[x == 'No Info'] <- NA
  # Replace empty string with NA
  x[x == ''] <- NA
  return(x)
}

startups <- map_df(startups, set_missing)
```

## Variables Correct type
### Factor Variables

Construct factor of factor variables and convert them

```{r convert_factors}
factor_cols <- c(2, 12, 16:17, 24, 26:65, 67, 71, 73, 75:87, 89:91, 93, 97, 100:101)
startups[, factor_cols] <- map_df(startups[, factor_cols], toupper)
startups[, factor_cols] <- map_df(startups[, factor_cols], as.factor)
```

Let us look at the `summary` for each variable to make sure that everything is ok.
```{r convert_factors_summary}
map(startups[, factor_cols], summary)
```

It seems that everything in order. However, there is a small note about some variables are about the *investors/owners/founders* not about the company itself which should not be there as certainly each person has his/her own qualifications and experience, but for sake of simplicity we will consider these varaibles are talking about all of these people at once as one unit.

### Numeric Variables
Construct factor of numeric variables and convert them

```{r convert_numeric, message=FALSE, warning=FALSE}
numeric_cols <- c(3:5,10,11,18:23,25,61,66,68:70,72,74,88,92,94:96,98,99,102:116)
startups[, numeric_cols] <- map_df(startups[, numeric_cols], as.numeric)
```

Let us look at the `summary` for each variable to make sure that everything is ok.
```{r convert_numeric_summary}
map(startups[, numeric_cols], summary)
```

It seems that seems that there are some outliers there, we will find out more we reach the EDA phase.

### Date Variables
Construct factor of date variables and convert them

```{r convert_date}
date_cols <- c(13:14)
startups[, date_cols] <- map_df(startups[, date_cols], mdy)
```

Let us look at the `summary` for each variable to make sure that everything is ok.
```{r convert_date_summary}
map(startups[, date_cols], summary)
```

## Remove polluted predictors
Now, as the variables in their proper data types, let us remove predictors with more than 40% missing data

```{r remove_poll_vars}
startups <- startups[colSums(is.na(startups))/nrow(startups) < .4]
dim(startups)
```
It seems we git rid off 3 variables, let us take another look at the data now
```{r top_5}
head(startups)
```

Much better.

## Feature Engineering
### Textual Variables
Textual columns are those that contain *free text*. What differentiates these from the categorical columns is that the number of unique values for the textual columns would be too big. Such columns are typically messy, and we will have to deal with them on a column-by-column basis as no single preprocessing procedure would suit them all.

Before we move on, let's modify the column names by making them lowercase and replacing spaces with underscores. Note that this is more of a personal preference than a neccessity.
```{r modify_colnames}
colnames(startups) <- tolower(gsub(x = colnames(startups), pattern = ' ', replacement = '_', fixed = TRUE))
# the 'fixed' parameter is set as TRUE in order to match the pattern exactly. 
# otherwise, the pattern will be interpreted as a regular expression instead, and an unexpected output may result.

# see effect of last command
head(colnames(startups))
```
After a quick manual inspection (on the .csv file), we identified the following textual variables. We additionally set the contents of these columns to lowercase for easier processing later on.
```{r textual_vars}
# the columns containing text in them
textual_col_names <- c('industry_of_company',
                       'short_description_of_company_profile',
                       'focus_functions_of_company',
                       'investors')

# set contents of these columns to lowercase
startups[,textual_col_names] <- map_df(startups[,textual_col_names], tolower)
```




#### Industry of the Company
And now, a quick look at the *industry_of_company* column -- which indicates the particular domain that a company is working in -- shows us...

```{r comp_indust}
head(startups$industry_of_company, 10)
```
From the output, it seems that it is a multiple-value variable with `|` as the separator.

Now, we wish to create a [*document-term matrix*](https://en.wikipedia.org/wiki/Document-term_matrix) (DTM) from this column. The DTM is a matrix where the documents (i.e. records) and terms (e.g. words) are the rows and columns, respectively, and the cells contain the frequencies of the terms occurring in the documents (e.g. the cell *DTM(i,j)* would tell how many times term *j* occurred in document *i*).  To generate the DTM, we shall use the [quanteda](https://cran.r-project.org/web/packages/quanteda/) package.

```{r }
# create the corpus object from the industry_of_company column
mycorpus <- corpus(startups$industry_of_company)

# generate the DTM using the formed corpus
dfm_industry <- dfm(mycorpus,               # the corpus to generate the DTM from
                    tolower = FALSE)        # data is already lowercase
```

At this point, let's just have a look at the DTM before moving on.

```{r }
# observe the 'terms' of the DTM
colnames(dfm_industry)
```

Unfortunately, the output is unsatisfactory. Some of the terms that are parsed by the [quanteda](https://cran.r-project.org/web/packages/quanteda/) package include `|`, `/`, `&`, `(` and `)` (improper terms, obviously). We also observe that industries such as `cloud computing` and `software development` have been broken down into their constituent words, which is also incorrect.

With some investigation of the [quanteda](https://cran.r-project.org/web/packages/quanteda/) package (specifically the `quanteda::tokens()` function), it seems that it is only able to split the terms over the *spaces* in the text. In other words, we cannot specify the `|` character as the separator for splitting the text into terms.

As such, we will deal with this issue by performing the following actions:

* **Replace spaces with underscores:** merges each of the multi-word industries into a single term.
* **Replace occurrences of the `|` character with spaces:** helps the `quanteda::dfm()` function split the terms over the new spaces.
* **Remove the special characters, `/`, `&`, `(` and `)`:** makes life easier for the `quanteda::dfm()` function.

It may be a good idea to look at the cases on which we intend to perform the above actions. Let's have a look.

```{r }
# retrieve and view those industries that have '/' in them
startups$industry_of_company[ grepl(x = startups$industry_of_company, pattern = '/', fixed = TRUE) ]
```

```{r }
# retrieve and view those industries that have '&' in them
startups$industry_of_company[ grepl(x = startups$industry_of_company, pattern = '&', fixed = TRUE) ]
```

```{r }
# retrieve and view those industries that have '(' in them
startups$industry_of_company[ grepl(x = startups$industry_of_company, pattern = '(', fixed = TRUE) ]
```

From the above inspections, it seems that all occurrences of `/` are in the terms `network / hosting / infrastructure` and `career / job search`. As for `&` and `(`, their occurrences are in the terms `food & beverages` and `human resources (hr)`, respectively. Accordingly, we perform the following modifications to the `industry_of_company` variable.

```{r }
# remove all occurrences of ' (hr)', ' /', ' &'
startups$industry_of_company <- gsub(startups$industry_of_company, pattern=' (hr)', replacement='', fixed=TRUE)
startups$industry_of_company <- gsub(startups$industry_of_company, pattern=' /',    replacement='', fixed=TRUE)
startups$industry_of_company <- gsub(startups$industry_of_company, pattern=' &',    replacement='', fixed=TRUE)

# replace spaces with underscores to merge multi-word terms
startups$industry_of_company <- gsub(startups$industry_of_company, pattern=' ',     replacement='_', fixed=TRUE)

# replace all occurrences of '|' with spaces to separate between terms
startups$industry_of_company <- gsub(startups$industry_of_company, pattern='|',     replacement=' ', fixed=TRUE)

head(startups$industry_of_company, 10)
```

Modifications have been applied successfully and as intended; i.e. multi-word terms are merged with underscores, and the terms are separated by spaces. Now, let's generate the DTM and observe the obtained terms.

```{r }
# create the corpus object from the industry_of_company column
mycorpus <- corpus(startups$industry_of_company)

# generate the DTM using the formed corpus
dfm_industry <- dfm(mycorpus,               # the corpus to generate the DTM from
                    tolower = FALSE)        # data is already lowercase

# observe the 'terms' of the DTM
colnames(dfm_industry)
```
At last, we can move on to the *analysis* of the `industry_of_company` variable.

Let's create a new data frame object where we bind the industry's DTM with the column of the response variable. Note that the DTM is currently of type `matrix`, so we need to coerce it into a `data.frame` before binding.

```{r }
# convert `dfm_industry` to data.frame and bind with response variable
startups_industry <- cbind(startups[,2], as.data.frame(dfm_industry))

glimpse(startups_industry)
```

The bind appears to be successful. Now, let's view the frequency of each of the industries among the list of companies in the dataset. Let's remove the `NA` industry as it does nothing for us.

```{r }
# remove the NA industry (column)
startups_industry <- 
  startups_industry %>% 
  select(-`NA`)

glimpse(startups_industry)
```

Alright. Let's now view the successes and failures under each industry. Specifically, we want (1) to have the rows be the industries and (2) to have two columns, *success* and *fail*, showing us the numbers of successful and failed companies, respectively, in each of the industries.

```{r }
# (1) have the rows be the industries
industry_frequencies <-
  startups_industry %>% 
  # "industry" column gathers the industries (i.e. keys) from the former columns
  # "binary" column holds the values from the former columns
  gather("industry", "binary", 2:41) %>% 
  #summarise the binary columns from the DTM into two values per industry (one for success/fail each)
  group_by(`dependent-company_status`, industry) %>% 
  summarise(frequency = sum(binary))

industry_frequencies
```

```{r }
# (2) have two columns, 'success' and 'failed'
industry_frequencies <-
  industry_frequencies %>% 
  spread(`dependent-company_status`, frequency)

# make column names lowercase
colnames(industry_frequencies) <- tolower(colnames(industry_frequencies))

industry_frequencies %>% 
  arrange(desc(success))
```

Let's visualize the above information.

```{r fig.align='center'}
# visualize number of successful companies per industry
industry_frequencies %>% 
  transform(industry=reorder(industry, -success) ) %>%        # order x-axis labels by '-success'
  ggplot(aes(x = industry, y = success)) +                    # X: industry, Y: #successful companies
  geom_bar(stat="identity") +                                 #
  theme(axis.text.x = element_text(angle = 90,                # rotate orientation of x-axis labels
                                   vjust = 0.3,               # top-align x-axis labels
                                   hjust = 1))                # right-align x-axis labels
```

```{r fig.align='center'}
# visualize number of successful/failed companies per industry
industry_frequencies %>% 
  gather("company_status", "n", 2:3) %>% 
  transform(industry=reorder(industry, -n) ) %>%              # order x-axis labels by '-success'
  ggplot(aes(x = industry, y = n, fill = company_status)) +   # X: industry, Y: n, fill: company_status
  geom_bar(stat="identity") +                                 #
  theme(axis.text.x = element_text(angle = 90,                # rotate orientation of x-axis labels
                                   vjust = 0.3,               # top-align x-axis labels
                                   hjust = 1))                # right-align x-axis labels
```

From the figure, it seems that most startups actually succeed regardless of the industry. Why don't we get some exact numbers? Below, we will create a new variable called `success_percent` which displays the percentage of successful companies per industry.

```{r }
# view industries arranged by percentage of successful companies per industry
industry_frequencies %>% 
  mutate(success_percent = round(success / (success+failed) * 100, 1)) %>% 
  arrange(desc(success_percent), desc(success))
```

Ahem... I want to see the ENTIRE thing, please?

```{r }
# view industries arranged by percentage of successful companies per industry
industry_frequencies %>% 
  mutate(success_percent = round(success / (success+failed) * 100, 1)) %>% 
  arrange(desc(success_percent), desc(success)) %>% 
  as.data.frame()   # override dplyr's tibble output
```

All endeavors in `retail`, `security` and `hospitality` seem to have ended in success. There are other industries that have flawlessly succeeded as well, but the number of successes are not big enough to be significant. 

For the industries with success ratios < 100%, `analytics` seems to be wildly successful with a ~91% success ratio, followed by `enterprise_software`, `marketing` and `advertising`, all with success ratios > 70%. There are still other industries with success ratios > 70%, but (again) the number of companies in these industries are not big enough for the percentages to be significant. 

On the other side of the spectrum, there exist industries that are wildly UNsuccessful such as `space_travel` and `classifieds`. Although the numbers of companies are not significant enough to draw conclusions, we don't need numbers to tell us that `space_travel` is a tough business to get into :). Other industries with more fails than successes are `music`, `food_beverages` and `search`. 

Industries in the *hit-or-miss* region (~50% success ratio) include `entertainment`, `network_hosting_infrastructure`, `education` and `telecommunications`. Again, other industries within this *hit-or-miss* region do not have a significantly large number of companies to constitute a trend and, as such, will be ignored.

Below, we take another quick look at the industries containing the bigger numbers of successful companies.

```{r }
# view industries arranged by percentage of successful companies per industry
industry_frequencies %>% 
  mutate(success_percent = round(success / (success+failed) * 100, 1)) %>% 
  arrange(desc(success), desc(success_percent))
```

We realize that while not all of the above 10 industrues contain superb success percentages, they are all > 60%.

Now, let's have a look at one of the industries (as an example), particularly its failed companies. We shall observe the `analytics` industry.

```{r }
analytic_startups_failed <- 
  startups_industry %>% 
  filter(analytics == 1, `dependent-company_status` == 'FAILED') %>%
  select(-c(`dependent-company_status`, `analytics`))   # don't need these columns anymore

analytic_startups_failed[,colSums(analytic_startups_failed) > 0] %>% 
  colSums() %>% 
  sort() %>% 
  t() %>% t()
```

Nothing particularly interesting here. Let's try the same thing, but with the successful companies of the `analytics` industry.

```{r }
analytic_startups_success <- 
  startups_industry %>% 
  filter(analytics == 1, `dependent-company_status` == 'SUCCESS') %>%
  select(-c(`dependent-company_status`, `analytics`))   # don't need these columns anymore

analytic_startups_success[,colSums(analytic_startups_success) > 0] %>% 
  colSums() %>% 
  sort() %>% 
  t() %>% t()
```

The hot industries in `analytics` seems to be the `marketing`, `mobile`, `e-commerce`, `enterprise_software` and `advertising` industries. Let's do some SUCCESS/FAILED comparison.

```{r }
# summarize the industries within 'analytics'
analytic_startups_summary <- t(rbind(colSums(analytic_startups_failed), colSums(analytic_startups_success)))

# modify column names
colnames(analytic_startups_summary) <- c('failed','success')

analytic_startups_summary[order(-analytic_startups_summary[,2]),]
```

The above output would look more interesting visualized.

```{r fig.align='center'}
# add the industries (currently the row names) as a column in 'analytic_startups_summary'
analytic_startups_summary <- cbind(rownames(analytic_startups_summary), analytic_startups_summary)

# remove the row names
rownames(analytic_startups_summary) <- NULL

# set the column names
colnames(analytic_startups_summary) <- c('industry','failed','success')

# convert to data frame
analytic_startups_summary <- as.data.frame(analytic_startups_summary, stringsAsFactors = FALSE)

# convert the numeric columns to type 'numeric'
analytic_startups_summary[,c("failed","success")] <- 
  map_df(analytic_startups_summary[,c("failed","success")], as.numeric)

# visualize number of successful/failed analytics companies per industry
analytic_startups_summary %>% 
  gather("company_status", "n", 2:3) %>% 
  transform(industry=reorder(industry, -n) ) %>%              # order x-axis labels by '-success'
  ggplot(aes(x = industry, y = n, fill = company_status)) +   # X: industry, Y: n, fill: company_status
  geom_bar(stat="identity") +                                 #
  theme(axis.text.x = element_text(angle = 90,                # rotate orientation of x-axis labels
                                   vjust = 0.3,               # top-align x-axis labels
                                   hjust = 1))                # right-align x-axis labels
```

The [ggplot2](https://cran.r-project.org/web/packages/ggplot2/) prefers the data be in a *tidy* format (all variables in columns, all observations in rows, all cells containing a single value each). As far as the `ggplot()` function is concerned, it is expecting us to specify a variable (column) as the x-axis and another variable (column) as the y-axis. This is why the industries were added as a column in the data frame (to be later displayed as the x-axis in the visualization). The `dplyr::gather()` function was used to produce a nice-looking visualization of the entire data together (instead of just either the failed or succesful companies alone).

Let's do the above analysis again but for companies that do NOT have `analytics` as one of its industries.

```{r }
non_analytic_startups_failed <- 
  startups_industry %>% 
  filter(analytics == 0, `dependent-company_status` == 'FAILED') %>%
  select(-c(`dependent-company_status`, `analytics`))   # don't need these columns anymore

non_analytic_startups_success <- 
  startups_industry %>% 
  filter(analytics == 0, `dependent-company_status` == 'SUCCESS') %>%
  select(-c(`dependent-company_status`, `analytics`))   # don't need these columns anymore

# summarize the industries within 'analytics'
non_analytic_startups_summary <- t(rbind(colSums(non_analytic_startups_failed),
                                         colSums(non_analytic_startups_success)))

# modify column names
colnames(non_analytic_startups_summary) <- c('failed','success')

non_analytic_startups_summary[order(-non_analytic_startups_summary[,2]),]
```

```{r fig.align='center'}
# add the industries (currently the row names) as a column in 'analytic_startups_summary'
non_analytic_startups_summary <- cbind(rownames(non_analytic_startups_summary), non_analytic_startups_summary)

# remove the row names
rownames(non_analytic_startups_summary) <- NULL

# set the column names
colnames(non_analytic_startups_summary) <- c('industry','failed','success')

# convert to data frame
non_analytic_startups_summary <- as.data.frame(non_analytic_startups_summary, stringsAsFactors = FALSE)

# convert the numeric columns to type 'numeric'
non_analytic_startups_summary[,c("failed","success")] <- 
  map_df(non_analytic_startups_summary[,c("failed","success")], as.numeric)

# visualize number of successful/failed non-analytics companies per industry
non_analytic_startups_summary %>% 
  gather("company_status", "n", 2:3) %>% 
  transform(industry=reorder(industry, -n) ) %>%              # order x-axis labels by '-success'
  ggplot(aes(x = industry, y = n, fill = company_status)) +   # X: industry, Y: n, fill: company_status
  geom_bar(stat="identity") +                                 #
  theme(axis.text.x = element_text(angle = 90,                # rotate orientation of x-axis labels
                                   vjust = 0.3,               # top-align x-axis labels
                                   hjust = 1))                # right-align x-axis labels
```

An interesting result, indeed! It seems that companies that adopt analytics capabilities have a much larger chance of success.

To finalize this analytics/non-analytics investigation, let's stack three visualizations (like the one above) on top of each other:
* the `analytics` companies
* the non-`analytics` companies
* all the companies.


```{r fig.align='center'}

library(gridExtra)

top_plot <- 
  industry_frequencies %>% 
  filter(industry != "analytics") %>%                         # ignore the 'analytics' industry
  gather("company_status", "n", 2:3) %>% 
  ggplot(aes(x = industry, y = n, fill = company_status)) +   # X: industry, Y: n, fill: company_status
  geom_bar(stat="identity") +                                 #
  theme(axis.title.x = element_blank(),                       # blanking out x-axis labels so 
        axis.text.x = element_blank(),                        # ...visualizations would fit on 
        axis.ticks.x = element_blank(),                       # ...top of each other
        axis.title.y = element_blank())                       # blanking out y-axis labels so 

middle_plot <- 
  analytic_startups_summary %>% 
  gather("company_status", "n", 2:3) %>% 
  ggplot(aes(x = industry, y = n, fill = company_status)) +   # X: industry, Y: n, fill: company_status
  geom_bar(stat="identity") +                                 #
  scale_y_continuous(limits = c(0,60)) +                      # fix limits for y-scale
  theme(axis.title.x = element_blank(),                       # blanking out x-axis labels so 
        axis.text.x = element_blank(),                        # ...visualizations would fit on 
        axis.ticks.x = element_blank(),                       # ...top of each other
        axis.title.y = element_blank())                       # blanking out y-axis labels so 

bottom_plot <- 
  non_analytic_startups_summary %>% 
  gather("company_status", "n", 2:3) %>% 
  ggplot(aes(x = industry, y = n, fill = company_status)) +   # X: industry, Y: n, fill: company_status
  geom_bar(stat="identity") +                                 #
  ylim(0,60) +                                                # fix limits for y-scale
  theme(axis.title.x = element_blank(),                       # blanking out x-axis labels so 
        axis.text.x = element_blank(),                        # ...visualizations would fit on 
        axis.ticks.x = element_blank(),                       # ...top of each other
        axis.title.y = element_blank())                       # blanking out y-axis labels so 

grid.arrange(top_plot, middle_plot, bottom_plot, ncol=1)
```

The above figure confirms what we already know about the data so far, and that is: `analytics` dramatically increases the chances that a startup will ultimately succeed.

Now that we performed some data analysis revolving around the `analytics` industry, we want to do something systematic over all the industries. First, we want to make sure that, for example, `mobile analytics` and `analytics mobile` to count as two separate industries. We also want to shorten the words for visualization purposes later.

```{r }
# alphabetically sorts the list of industries for each company
industrySorter<- function(industries) {
  if(is.na(industries)) {
    industries <- ""
  } 
  else {
    industries <-                 # e.g. "gaming entertainment mobile"
      industries %>%              #
      strsplit(" ") %>%           # "gaming" "entertainment" "mobile"
      unlist() %>%                #
      sort() %>%                  # "entertainment" "gaming" "mobile"
      tokens() %>%
      tokens_wordstem() %>%       # "entertain" "game" "mobil"
      paste(collapse = " ")       # "entertain game mobil"
  }
  return(industries)
}
startups$industry_of_company <- map_chr(startups$industry_of_company, industrySorter)

startups$industry_of_company %>% 
  head(10)
```

```{r }
# show all the industry combinations in the data and the number of companies in each
startups%>% 
  group_by(industry_of_company) %>% 
  summarise(companies = n()) %>% 
  arrange(industry_of_company)       # sort industries alphabetically
```

```{r }
# show all the industry combinations in the data and the number of companies in each
startups%>% 
  group_by(industry_of_company) %>% 
  summarise(companies = n()) %>% 
  arrange(desc(companies))       # sort industries by number of companies
```

Let's try doing something more useful.

```{r }
# show all the industry combinations in the data and the number of failed/successful companies in each
startups%>% 
  group_by(industry_of_company, `dependent-company_status`) %>% 
  summarise(companies = n()) %>% 
  arrange(desc(companies))       # sort industries by number of companies
```

Let's convert the above data into a *tidy* format.

```{r }
# show all the industry combinations in the data and the number of failed/successful companies in each
startups%>% 
  group_by(industry_of_company, `dependent-company_status`) %>% 
  summarise(companies = n()) %>% 
  spread(`dependent-company_status`, companies) %>% 
  arrange(desc(SUCCESS))       # sort industries by number of successful companies
```

Let's remove the first row (corresponding to the `NA` industry) and replace the NA's within the table with 0's.

```{r }
my_summarised_startups_industry <- 
  startups%>% 
  group_by(industry_of_company, `dependent-company_status`) %>% 
  summarise(companies = n()) %>% 
  spread(`dependent-company_status`, companies) %>% 
  filter(industry_of_company != "") %>% 
  arrange(desc(SUCCESS))       # sort industries by number of successful companies

# replace the NA's with 0's
my_summarised_startups_industry[is.na(my_summarised_startups_industry)] <- 0

my_summarised_startups_industry
```

It appears we have 173 unique indutry combinations in the data. Let's visualize them. Note, however, that these industry combinations would never all fit on the x-axis which is why

```{r fig.align='center'}
my_summarised_startups_industry %>% 
  head(25) %>%
  gather("company_status","n",2:3) %>% 
  mutate(short_indust = strtrim(industry_of_company, 20)) %>% 
  transform(short_indust=reorder(short_indust, -n) ) %>%      # order x-axis labels by '-n'
  ggplot(aes(x=short_indust, y=n, fill=company_status)) +     # X: industry, Y: #successful companies
  geom_bar(stat="identity") +                                 #
  theme(axis.text.x = element_text(angle = 90,                # rotate orientation of x-axis labels
                                   vjust = 0.3,               # top-align x-axis labels
                                   hjust = 1))                # right-align x-axis labels
```

Now, let's show the industry combinations with the highest fail rates.

```{r }
my_summarised_startups_industry <-
  my_summarised_startups_industry %>% 
  arrange(desc(FAILED))

my_summarised_startups_industry
```

```{r fig.align='center'}
my_summarised_startups_industry %>% 
  head(25) %>%
  gather("company_status","n",2:3) %>% 
  mutate(short_indust = strtrim(industry_of_company, 20)) %>% 
  transform(short_indust=reorder(short_indust, -n) ) %>%      # order x-axis labels by '-n'
  ggplot(aes(x=short_indust, y=n, fill=company_status)) +     # X: industry, Y: #successful companies
  geom_bar(stat="identity") +                                 #
  theme(axis.text.x = element_text(angle = 90,                # rotate orientation of x-axis labels
                                   vjust = 0.3,               # top-align x-axis labels
                                   hjust = 1))                # right-align x-axis labels
```

*To be continued...*



















#### Short description of company profile

Until now I do not know what to do with it

```{r desc}
head(startups$short_description_of_company_profile, 10)
```

The NA's will probably cause problems at the DTM generation step later, so let's remove them.

```{r }
# eliminate NA's
startups$short_description_of_company_profile[is.na(startups$short_description_of_company_profile)] <- ''

head(startups$short_description_of_company_profile, 10)
```

Let's carry on and generate the DTM matrix.

```{r }
# create the corpus object from the short_description_of_company_profile column
mycorpus <- corpus(startups$short_description_of_company_profile)

# generate the DTM using the formed corpus
dfm_desc <- dfm(mycorpus,               # the corpus to generate the DTM from
                tolower = FALSE)        # data is already lowercase
```

Like before, let's have a look at the DTM before moving on.

```{r }
# observe the 'terms' of the DTM
colnames(dfm_desc)
```

Surfing through the different terms, you can find punctuations (e.g. `)`, `.`, `/`, etc.) as well as some stop words (e.g. `the`, `you`, etc.). Why don't we remove those?

```{r }
# create the corpus object from the short_description_of_company_profile column
mycorpus <- corpus(startups$short_description_of_company_profile)

# remove the suffix "'s"
mycorpus <- gsub(x = mycorpus, pattern = "'s", replacement = "", fixed = TRUE)

# list of stop words
my_stopwords <- stopwords('english')

# generate the DTM using the formed corpus
dfm_desc <- dfm(mycorpus,               # the corpus to generate the DTM from
                remove_punct = TRUE,    # remove punctuation
                remove_numbers = TRUE,  # remove numbers
                remove_symbols = TRUE,  # remove symbols
                remove = my_stopwords,  # remove stopwords
                tolower = FALSE)        # data is already lowercase

# observe the 'terms' of the DTM
sort(colnames(dfm_desc))
```

That's better, but there are terms containing only a single letter. What's up with that? We need to look at some of the records (i.e. companies) that possess these single-lettered terms. By the way, we see the `<U+FB01>nancial` term, but we are just ignoring it for now.

```{r }
# show the cases having the 'r' term
startups$short_description_of_company_profile[as.logical(dfm_desc[,"r"])]
```

```{r }
# show the cases having the 's' term
startups$short_description_of_company_profile[as.logical(dfm_desc[,"s"])]
```

Okay. The `r` term makes sense, but the `s` does not seem very useful. We could remove it by hand, but let's see if there is a more systematic way to do that.

```{r }
# compute the sums of the columns of the DTM
colSums(dfm_desc) %>% 
  head(30)
```

Let's reproduce the above output again but, this time, let's sort and convert to a data frame. Viewing a datframe has a nicer look to it (one value per row).

```{r }
colSums(dfm_desc) %>% 
  sort(decreasing = TRUE) %>% 
  as.data.frame() %>% 
  head(30)
```

Why don't we look at an overall summary of the above output?

```{r }
colSums(dfm_desc) %>% 
  sort(decreasing = TRUE) %>% 
  as.data.frame() %>% 
  summary()
```

More than half the terms have the lowest possible frequency, 1. Let's produce a kernel matrix showing similarities between the 10 highest frequency terms and see if we can glean any insights.

```{r }
getKernel <- function() {
  krnl <- 
  return()
}

```

#### Focus functions of company
It is a multi-value variable indicate the company foucs.

```{r comp_foc}
head(startups$focus_functions_of_company, 10)
```
The following are some notes about this field:
* values are either seprated by `,` or `&` and sometimes both.
* The characters case is not standarized.
* Missing functions




#### Investors
It is a multi-value variable. Values are seprated by `|`, and sometimes there are missing values
```{r investors}
head(startups$investors, 10)
```

















### Time Series Variables
This category contains the following two fields `Est. Founding Date` and `Last Funding Date`, so let us begin.
#### Missing Values
First we have to impute the missing values
```{r impute_missing_time}
#founding_date <- na.locf(startups$`Est. Founding Date`, na.rm = FALSE)
#startups$`Est. Founding Date` <- na.locf(founding_date, fromLast = TRUE)
#summary(startups$`Est. Founding Date`)

#last_funding_date <- na.locf(startups$`Last Funding Date`, na.rm = FALSE)
#startups$`Last Funding Date` <- na.locf(last_funding_date, fromLast = TRUE)
#summary(startups$`Last Funding Date`)
```


#### EDA
```{r ts_eda}
#ggplot(startups, aes(x = `Est. Founding Date`, y = `Dependent-Company Status`)) +
#  geom_point() +
#  scale_x_date('month')  +
#  ylab("Daily Bike Checkouts") +
#  xlab("")
#ggplot(daily_data, aes(Date, cnt)) + geom_line() + scale_x_date('month')  + ylab("Daily Bike Checkouts") +
#            xlab("")
```

# Exploratory Data Analysis

# Feature Engineering

# Pre-Modeling Processing
## Missing Values

## More Exploration

## Hypothesis Testing

## Predictor Selection
